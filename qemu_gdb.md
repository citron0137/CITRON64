# Intro

## 쌩 부팅과정 Qemu와 GDB로 리버싱 하기 입니다.
~~(간지나는)~~ 다른 말로, MBR 레벨에서 커널 디버깅 하기

### 현 실습은 우분투 bash 환경에서 진행하는 것을 기준으로 작성되었습니다.

### 이해를 하지 못하거나 진행이 막힌 경우에는 누구든 부담없이 연락부탁드립니다.
https://www.facebook.com/profile.php?id=100004945183754

### (뉴비 대 환영!!! 처음부터 막혀도 연락주면 리눅스 명령어까지 다 알려줘요!!!)
~~(정작 본인이 늅늅)~~

# 0. 실습파일 준비하기

citron64OS를 clone합니다.
```
git clone https://github.com/citron00137/CITRON64OS
```

실습환경으로 checkout합니다.

```
cd CITRON64OS

git checkout fb2052
```
다음과 같은 명령어가 출력된다면 성공한 것입니다.
```
Head is now at fb2052 ~~~~~~~~~~~~~~~~~~~~
```

 
# 1. 플로피 디스크 이미지로 부팅하기

Disk.img 파일이 있는 CITRON64OS의 CITRON64 디렉터리에서 진행합니다.
```
cd CITRON64
```

가장 먼저 start.sh 파일을 작성 합니다.

```
qemu-system-x86_64 -L . -m 256 -fda Disk.img -localtime -M pc
```

이제 터미널에서 ./start.sh 명령어를 치면 정상적이지는 않지만 부팅이 됩니다.

혹시 정상적인 실행을 보고싶다면 vmware실습을 참고하시길 바랍니다.

# 2. Qemu 디버깅 옵션

start.sh 파일 뒤에 -s -S를 추가해 줍니다.

```
qemu-system-x86_64 -L . -m 256 -fda Disk.img -localtime -M pc -s -S
```
이제 ./start.sh 명령어를 실행시키면 검정색 화면에서 멈춰있습니다.

상단바에 [Stopped] 라는 표시가 생깁니다.

이제 현재 컴퓨터의 1234 포트로 디버깅을 할 수 있습니다.

# 3. gdb로 디버깅 하기


gdb 명령어로 gdb를 실행시킵니다.

```
gdb
```

target retmote :포트번호 명령어를 통해 gdb를 attach합니다.
```
(gdb) target remote :1234
```

0xfffe에 브레이킹 포인트가 잡혀있습니다.

소스코드를 분석해서 원하는 위치에 브레이킹 포인트를 추가합니다.

브레이킹 포인트를 추가할 때 심볼이 없으므로 주소를 지정해야 합니다.

```
(gdb) b *0x7c00

(gdb) b *0x10200

(gdb) b *0x200000
```
위에서 부터 순서대로 bootloader, 32bit kernel, 64bit kernel의 시작 주소입니다.

continue 명령어를 통해 다음 브레이크 포인트 까지 진행합니다.

```
(gdb) c
```
+) ni, si 명령어들은 지원이 안될 수 있습니다. (자세한 이유가 궁금하시면 페메 부탁드립니다.)

각 브레이크 포인트에서 멈췄으면, disas 명령어를 통해 어셈블리 코드로 변환합니다.

disas <분석을 시작할 주소>, <분석을 끝 낼 주소> 
```
(gdb) disas $rip, $rip+0x1000
```
이제 어셈블리어 코드를 볼 수 있습니다.

$rip대신 특정 메모리 주소를 입력하면
메모리를 동적으로 할당하기 때문에 해당 주소에 아직 코드가 매핑되지 않았을 수도 있습니다.

위와 같이 진행을 하다보면 64bit 커널에서 어떠한 함수가 반복되어 작성된 것을 볼 수 있습니다.

하지만 소스코드와 비교를 해 보면 qemu에 오류가 있다는 사실을 알 수 있습니다.